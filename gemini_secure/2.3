import secrets
from datetime import datetime, timedelta
from fastapi import APIRouter, HTTPException, BackgroundTasks
from pydantic import EmailStr, BaseModel

router = APIRouter()

# Имитация базы данных и функции отправки почты
fake_db_users = {"user@example.com": {"id": 1, "name": "Иван"}}
reset_tokens = {} # В продакшене используйте Redis или БД

class ResetRequest(BaseModel):
    email: EmailStr

def send_email_task(email: str, token: str):
    link = f"https://yourapp.com/password-reset/confirm?token={token}"
    print(f"Отправка письма на {email}: {link}")
    # Здесь логика отправки через SMTP или API (SendGrid, Mailgun)

@router.post("/password-reset/request")
async def request_password_reset(data: ResetRequest, background_tasks: BackgroundTasks):
    user = fake_db_users.get(data.email)
    
    # CWE-209: Не сообщаем, существует ли email в базе, 
    # чтобы избежать перебора (User Enumeration).
    if user:
        # Генерируем URL-safe токен (криптографически стойкий)
        token = secrets.token_urlsafe(32)
        
        # Сохраняем токен с привязкой к пользователю и временем истечения
        reset_tokens[token] = {
            "email": data.email,
            "expires": datetime.utcnow() + timedelta(hours=1)
        }
        
        # Отправляем письмо в фоновом режиме
        background_tasks.add_task(send_email_task, data.email, token)

    return {"message": "Если адрес зарегистрирован, письмо со ссылкой будет отправлено."}
