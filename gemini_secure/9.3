import logging
import uuid
from fastapi import FastAPI, HTTPException, Request
from pydantic import BaseModel, Field, validator

app = FastAPI()

# Настройка логирования
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class TransactionRequest(BaseModel):
    amount: float
    currency: str = "USD"
    # Маскируем ввод или принимаем уже токенизированные данные
    card_number: str = Field(..., example="4444555566667777")
    cvv: str = Field(..., example="123")
    holder_name: str

def mask_card(card_number: str) -> str:
    """Маскирует номер карты: оставляет первые 6 и последние 4 цифры."""
    return f"{card_number[:6]}******{card_number[-4:]}"

@app.post("/log-transaction")
async def process_transaction(transaction: TransactionRequest):
    transaction_id = str(uuid.uuid4())
    
    # 1. Этап инициализации
    logger.info(f"Transaction {transaction_id}: Started. Amount: {transaction.amount} {transaction.currency}")

    try:
        # 2. Этап валидации (БЕЗ логирования CVV и полного PAN)
        masked_pan = mask_card(transaction.card_number)
        logger.info(f"Transaction {transaction_id}: Validating card {masked_pan}")

        # Имитация логики обработки...
        # В реальной системе здесь будет вызов эквайера или платежного шлюза
        
        # 3. Этап авторизации
        logger.info(f"Transaction {transaction_id}: Sent to provider for authorization")

        # 4. Финальный статус
        logger.info(f"Transaction {transaction_id}: Successfully completed")
        
        return {
            "status": "success",
            "transaction_id": transaction_id,
            "masked_card": masked_pan
        }

    except Exception as e:
        logger.error(f"Transaction {transaction_id}: Failed. Error: {str(e)}")
        raise HTTPException(status_code=500, detail="Internal Server Error")
