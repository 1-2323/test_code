from fastapi import FastAPI, HTTPException, BackgroundTasks
from pydantic import BaseModel, Field
from typing import Dict, Any
import logging

app = FastAPI()

# Настройка логирования
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Схема входящих данных
class ConfigUpdate(BaseModel):
    version: str = Field(..., example="1.2.0")
    settings: Dict[str, Any]
    metadata: Dict[str, Any] = {}

def apply_configuration(config: ConfigUpdate):
    """
    Логика применения конфигурации:
    Здесь может быть запись в БД, обновление переменных окружения
    или перезапуск внутренних сервисов.
    """
    try:
        logger.info(f"Начало применения конфигурации версии {config.version}...")
        # Имитация логики применения
        # save_to_db(config.settings)
        logger.info("Конфигурация успешно применена.")
    except Exception as e:
        logger.error(f"Ошибка при применении конфигурации: {e}")

@app.post("/update", status_code=202)
async def update_config(config: ConfigUpdate, background_tasks: BackgroundTasks):
    """
    Эндпоинт для приема обновлений.
    Использует BackgroundTasks, чтобы быстро ответить отправителю (HTTP 202),
    пока тяжелая логика обновления выполняется в фоне.
    """
    if not config.settings:
        raise HTTPException(status_code=400, detail="Settings cannot be empty")

    # Добавляем задачу на применение в бэкграунд
    background_tasks.add_task(apply_configuration, config)
    
    return {
        "status": "accepted",
        "message": f"Update for version {config.version} is being processed"
    }

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
