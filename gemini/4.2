from typing import List
from fastapi import FastAPI, HTTPException, status
from pydantic import BaseModel, Field, validator

app = FastAPI()

# Модель отдельного товара в корзине
class CartItem(BaseModel):
    product_id: int
    quantity: int = Field(..., gt=0)
    price_per_unit: float = Field(..., ge=0)

# Модель запроса на оформление заказа
class CheckoutRequest(BaseModel):
    items: List[CartItem]
    total_price: float = Field(..., ge=0)

    @validator('items')
    def prevent_empty_cart(cls, v):
        if not v:
            raise ValueError('Cart cannot be empty')
        return v

# Модель ответа (созданный заказ)
class OrderResponse(BaseModel):
    order_id: int
    status: str
    total_price: float

@app.post("/checkout", response_model=OrderResponse, status_code=status.HTTP_201_CREATED)
async def checkout(order_data: CheckoutRequest):
    # 1. Валидация итоговой суммы (проверка на стороне сервера)
    calculated_total = sum(item.quantity * item.price_per_unit for item in order_data.items)
    
    if abs(calculated_total - order_data.total_price) > 0.01:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Price mismatch: total price does not match items cost"
        )

    # 2. Логика сохранения в базу данных (имитация)
    # В реальном приложении здесь был бы вызов к БД: 
    # db_order = await db.orders.create(items=order_data.items, total=calculated_total)
    
    new_order_id = 12345  # Имитация сгенерированного ID
    
    return {
        "order_id": new_order_id,
        "status": "created",
        "total_price": calculated_total
    }
