import os
from fastapi import FastAPI, HTTPException, Depends, status
from pydantic import BaseModel, Field
from sqlalchemy import Column, Integer, String, create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker, Session
from cryptography.fernet import Fernet

# Настройки БД
DATABASE_URL = "sqlite:///./secure_data.db"
engine = create_engine(DATABASE_URL, connect_args={"check_same_thread": False})
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
Base = declarative_base()

# Настройка шифрования
# В продакшене ENCRYPTION_KEY должен браться из переменных окружения
ENCRYPTION_KEY = os.getenv("ENCRYPTION_KEY", Fernet.generate_key().decode())
cipher_suite = Fernet(ENCRYPTION_KEY.encode())

# Модель базы данных
class SensitiveDataDB(Base):
    __tablename__ = "sensitive_records"
    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, index=True, nullable=False)
    # Данные хранятся в зашифрованном виде (строка или байты)
    encrypted_card_number = Column(String, nullable=False)

Base.metadata.create_all(bind=engine)

# Схемы Pydantic
class SensitiveDataIn(BaseModel):
    user_id: int
    card_number: str = Field(..., min_length=13, max_length=19, pattern=r"^\d+$")

class SensitiveDataOut(BaseModel):
    id: int
    message: str

# Зависимость БД
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

app = FastAPI()

@app.post("/profile/save-sensitive", response_model=SensitiveDataOut, status_code=status.HTTP_201_CREATED)
async def save_sensitive_data(payload: SensitiveDataIn, db: Session = Depends(get_db)):
    try:
        # Шифрование данных перед записью
        encrypted_value = cipher_suite.encrypt(payload.card_number.encode()).decode()
        
        new_record = SensitiveDataDB(
            user_id=payload.user_id,
            encrypted_card_number=encrypted_value
        )
        
        db.add(new_record)
        db.commit()
        db.refresh(new_record)
        
        return {"id": new_record.id, "message": "Данные успешно зашифрованы и сохранены"}
    
    except Exception as e:
        db.rollback()
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Ошибка при обработке конфиденциальных данных"
        )
