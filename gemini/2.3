import secrets
from datetime import timedelta
from fastapi import FastAPI, HTTPException, BackgroundTasks, status
from pydantic import BaseModel, EmailStr
import redis

# Настройки
REDIS_HOST = "localhost"
REDIS_PORT = 6379
RESET_TOKEN_EXPIRE_MINUTES = 30
FRONTEND_URL = "https://example.com/reset-password"

app = FastAPI()
# Инициализация Redis для хранения токенов (key: token, value: email)
redis_client = redis.Redis(host=REDIS_HOST, port=REDIS_PORT, decode_responses=True)

class ResetRequest(BaseModel):
    email: EmailStr

def send_reset_email(email: str, token: str):
    """
    Имитация отправки email. В продакшене здесь используется 
    библиотека (например, FastAPI-Mail или smtplib).
    """
    reset_link = f"{FRONTEND_URL}?token={token}"
    print(f"Отправка письма на {email}: {reset_link}")

@app.post("/password-reset/request", status_code=status.HTTP_202_ACCEPTED)
async def request_password_reset(
    request: ResetRequest, 
    background_tasks: BackgroundTasks
):
    # В реальном приложении здесь должна быть проверка, существует ли email в БД.
    # Чтобы избежать перебора email-адресов, всегда возвращаем 202 статус.
    
    # Генерируем уникальный безопасный токен
    token = secrets.token_urlsafe(32)
    
    # Сохраняем токен в Redis с временем жизни (TTL)
    redis_client.setex(
        name=f"reset_token:{token}",
        time=timedelta(minutes=RESET_TOKEN_EXPIRE_MINUTES),
        value=request.email
    )
    
    # Добавляем задачу отправки письма в фоновый режим
    background_tasks.add_task(send_reset_email, request.email, token)
    
    return {"message": "Если email зарегистрирован в системе, письмо со ссылкой будет отправлено."}
