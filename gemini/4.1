from fastapi import FastAPI, HTTPException, status
from pydantic import BaseModel, EmailStr
from passlib.context import CryptContext

app = FastAPI()

# Настройка контекста для хеширования паролей
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

# Модель входных данных
class RecoveryRequest(BaseModel):
    email: EmailStr
    secret_answer: str
    new_password: str

# Имитация базы данных (в реальном приложении используйте ORM/SQL)
users_db = {
    "user@example.com": {
        "hashed_password": "$2b$12$...", 
        "secret_answer_hash": "$2b$12$...", # Ответ на вопрос хранится в виде хеша
    }
}

@app.post("/recover", status_code=status.HTTP_200_OK)
async def recover_password(request: RecoveryRequest):
    user = users_db.get(request.email)
    
    if not user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="User not found"
        )

    # Проверка ответа на секретный вопрос
    is_answer_correct = pwd_context.verify(
        request.secret_answer.lower().strip(), 
        user["secret_answer_hash"]
    )

    if not is_answer_correct:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect secret answer"
        )

    # Обновление пароля
    new_hashed_password = pwd_context.hash(request.new_password)
    user["hashed_password"] = new_hashed_password

    return {"message": "Password reset successful"}
