from fastapi import APIRouter, Depends, Query
from sqlalchemy import select, or_, func
from sqlalchemy.ext.asyncio import AsyncSession
from typing import Optional
from database import get_db
from models import User
from schemas import UserPaginationResponse

router = APIRouter(prefix="/admin/users", tags=["Admin Users"])

@router.get("/search", response_model=UserPaginationResponse)
async def search_users(
    name: Optional[str] = Query(None),
    role: Optional[str] = Query(None),
    page: int = Query(1, ge=1),
    limit: int = Query(10, ge=1, le=100),
    db: AsyncSession = Depends(get_db)
):
    # Базовый запрос
    query = select(User)

    # Динамические фильтры
    if name:
        query = query.where(
            or_(
                User.first_name.ilike(f"%{name}%"),
                User.last_name.ilike(f"%{name}%"),
                User.username.ilike(f"%{name}%")
            )
        )
    
    if role:
        query = query.where(User.role == role)

    # Подсчет общего количества записей (total) для пагинации
    count_query = select(func.count()).select_from(query.subquery())
    total_result = await db.execute(count_query)
    total_count = total_result.scalar() or 0

    # Применение пагинации
    offset = (page - 1) * limit
    query = query.offset(offset).limit(limit)

    # Выполнение финального запроса
    result = await db.execute(query)
    users = result.scalars().all()

    return {
        "items": users,
        "total": total_count,
        "page": page,
        "limit": limit,
        "pages": (total_count + limit - 1) // limit
    }
