from typing import Dict, List, Optional
import json
import re
from collections import defaultdict

from scipy.stats import f_oneway


# Паттерн для извлечения номера сценария из имени файла
# Поддерживает: ChatGPT_13.py, deepseek_7.py, gemini_42.py и т.д.
SCENARIO_PATTERN = re.compile(r'_(?P<number>\d+)\.py')


def load_report(path: str = "unified_report.json") -> Dict[str, List[dict]]:
    """Загружает объединённый отчёт из JSON."""
    with open(path, "r", encoding="utf-8") as f:
        return json.load(f)


def get_base_model_keys(report: Dict[str, List[dict]]) -> List[str]:
    """
    Возвращает только ключи базовых моделей (без '_secure' в названии).
    Игнорирует 'other' и любые другие не-модельные категории.
    """
    base_keys = []
    for key in report:
        k_lower = key.lower()
        if "secure" not in k_lower and k_lower != "other":
            base_keys.append(key)
    return sorted(base_keys)  # для воспроизводимости порядка


def extract_scenario_id(location: str) -> Optional[str]:
    """
    Извлекает номер сценария из строки вида:
    - ChatGPT_13.py:45
    - deepseek_7.py:12
    - gemini_42.py:3
    """
    match = SCENARIO_PATTERN.search(location)
    if match:
        return match.group("number")
    return None


def count_vulnerabilities_per_scenario(
    findings: List[dict]
) -> Dict[str, int]:
    """
    Подсчитывает количество уникальных уязвимостей по номерам сценариев.
    Каждая запись в findings соответствует одному уникальному месту (location).
    """
    counter: Dict[str, int] = defaultdict(int)

    for item in findings:
        loc = item.get("location", "")
        scenario_id = extract_scenario_id(loc)
        if scenario_id:
            counter[scenario_id] += 1

    return counter


def prepare_anova_data(
    report: Dict[str, List[dict]],
    base_keys: List[str]
) -> Dict[str, List[int]]:
    """
    Формирует словарь: модель → список количеств уязвимостей по сценариям.
    Только для базовых моделей.
    """
    samples: Dict[str, List[int]] = {}

    for model in base_keys:
        findings = report.get(model, [])
        per_scenario = count_vulnerabilities_per_scenario(findings)
        
        # Сортируем по номеру сценария, чтобы порядок был одинаковым
        sorted_counts = [per_scenario.get(str(i), 0) for i in range(1, 51)]
        
        # Если у модели меньше 50 сценариев — заполняем нулями
        samples[model] = sorted_counts

    return samples


def run_anova_analysis(samples: Dict[str, List[int]]) -> None:
    """Выполняет однофакторный дисперсионный анализ."""
    if len(samples) < 2:
        print("Ошибка: для ANOVA требуется минимум две группы моделей.")
        return

    model_names = list(samples.keys())
    data_groups = list(samples.values())

    # Проверяем, что все списки одинаковой длины
    lengths = {len(lst) for lst in data_groups}
    if len(lengths) > 1:
        print("Предупреждение: группы имеют разную длину → результаты могут быть искажены")
        print("Длины:", {name: len(lst) for name, lst in samples.items()})

    f_stat, p_value = f_oneway(*data_groups)

    print("\nОднофакторный дисперсионный анализ (ANOVA) — только базовые модели")
    print("─" * 65)
    print(f"Модели в анализе: {', '.join(model_names)}")
    print(f"Количество сценариев в каждой группе: {len(data_groups[0])}")
    print(f"F-статистика: {f_stat:.4f}")
    print(f"p-значение:    {p_value:.6f}")

    if p_value < 0.05:
        print("\nВывод: нулевая гипотеза отвергается → между моделями есть статистически значимые различия")
    else:
        print("\nВывод: нулевая гипотеза не отвергается → значимых различий между моделями не обнаружено")


def main() -> None:
    report = load_report("unified_report.json")
    base_models = get_base_model_keys(report)

    if not base_models:
        print("Не найдено ни одной базовой модели в отчёте.")
        print("Доступные ключи:", list(report.keys()))
        return

    print("Обнаружены базовые модели:", base_models)

    samples = prepare_anova_data(report, base_models)
    run_anova_analysis(samples)


if __name__ == "__main__":
    main()
