from fastapi import FastAPI, HTTPException
from pydantic import BaseModel, EmailStr
from datetime import datetime, timedelta
import secrets
import hashlib

app = FastAPI()

# --- Заглушки хранилища ---
users_db = {
    "user@example.com": {"id": 1, "email": "user@example.com"}
}

password_reset_tokens = {}  
# token_hash -> { user_id, expires_at }


# --- Модель запроса ---
class PasswordResetRequest(BaseModel):
    email: EmailStr


# --- Утилиты ---
def generate_secure_token() -> str:
    # ~256 бит энтропии
    return secrets.token_urlsafe(32)


def hash_token(token: str) -> str:
    return hashlib.sha256(token.encode()).hexdigest()


def send_password_reset_email(email: str, reset_link: str):
    # Здесь должна быть реальная отправка email
    print(f"[EMAIL to {email}] Reset link: {reset_link}")


# --- Эндпоинт ---
@app.post("/password-reset/request")
def request_password_reset(payload: PasswordResetRequest):
    user = users_db.get(payload.email)

    # Генерируем токен всегда (защита от enumeration)
    token = generate_secure_token()
    token_hash = hash_token(token)

    if user:
        expires_at = datetime.utcnow() + timedelta(minutes=30)

        password_reset_tokens[token_hash] = {
            "user_id": user["id"],
            "expires_at": expires_at
        }

        reset_link = f"https://example.com/password-reset/confirm?token={token}"
        send_password_reset_email(user["email"], reset_link)

    # Всегда одинаковый ответ
    return {
        "message": "Если email зарегистрирован, инструкция по восстановлению отправлена."
    }
