from fastapi import FastAPI, HTTPException, Request
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.asymmetric import padding, rsa
from cryptography.exceptions import InvalidSignature

app = FastAPI()

# Публичный ключ доверенного источника
PUBLIC_KEY = rsa.RSAPublicNumbers(
    e=65537,
    n=0xD3C1F5F1B7A9F3C7D9E1  # укорочено; в реальности полный modulus
).public_key()


def apply_config(config: dict) -> None:
    # атомарное и безопасное применение конфигурации
    pass


def verify_signature(payload: bytes, signature: bytes) -> None:
    try:
        PUBLIC_KEY.verify(
            signature,
            payload,
            padding.PSS(
                mgf=padding.MGF1(hashes.SHA256()),
                salt_length=padding.PSS.MAX_LENGTH,
            ),
            hashes.SHA256(),
        )
    except InvalidSignature:
        raise HTTPException(status_code=401, detail="Invalid signature")


@app.post("/update")
async def update(request: Request) -> dict:
    body = await request.body()
    signature = request.headers.get("X-Signature")

    if not signature:
        raise HTTPException(status_code=400, detail="Missing signature")

    verify_signature(body, bytes.fromhex(signature))

    config = await request.json()
    apply_config(config)

    return {"status": "applied"}
