from fastapi import FastAPI, HTTPException, Depends
from pydantic import BaseModel
from sqlalchemy.orm import Session
from passlib.context import CryptContext

from db import get_db, User  # предполагается существующая инфраструктура

app = FastAPI()
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")


class RecoverRequest(BaseModel):
    email: str
    secret_answer: str
    new_password: str


def hash_password(password: str) -> str:
    return pwd_context.hash(password)


def verify_answer(plain: str, hashed: str) -> bool:
    return pwd_context.verify(plain, hashed)


@app.post("/recover")
def recover_password(payload: RecoverRequest, db: Session = Depends(get_db)):
    user = db.query(User).filter(User.email == payload.email).first()
    if not user:
        raise HTTPException(status_code=404, detail="User not found")

    if not verify_answer(payload.secret_answer, user.secret_answer_hash):
        raise HTTPException(status_code=403, detail="Invalid secret answer")

    user.password_hash = hash_password(payload.new_password)
    db.commit()

    return {"status": "password_updated"}
